/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build-web.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build-web.js":
/*!**********************!*\
  !*** ./build-web.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";'use strict';\n/*\n* @module uniSoc\n* @author plundell\n* @license Apache-2.0\n* @description Frontend component of uniSoc. Wraps around native WebSocket API (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n* @extends ./unisoc-common.js   \n* @depends libbetter\n* @exports n/a      This script should be bundled and loaded in the browser directly. It make the module available \n*                   available at window.uniSoc. If you want to require the web-component of uniSoc @see ./unisoc-web.js\n*/\n\n(function loadUniSoc(){\n    if(!window)\n        throw new Error(\"Could not access the 'window'. Cannot load uniSoc.\");\n\n    var exporter=__webpack_require__(/*! ./src/web.js */ \"./src/web.js\");\n\n    //Create a getter on the window which runs the exporter as soon as all dependencies are\n    //available OR throws a clear error if we try to access it too early\n    Object.defineProperty(window,'uniSoc',{enumerable:true, configurable:true\n    \t,get:()=>{\n    \t\tif(window.BetterLog && window.BetterEvents && window.BetterUtil){ \n    \t\t\treturn window.uniSoc=proto(window);\n    \t\t}else{\n    \t\t\tthrow new Error(\"E_DEPENDENCY. uniSoc depends on libbetter which should be set on the window.\");\n    \t\t}\n    \t}\n    \t//This setter allows^ the whole thing to easily be undone/overwritten\n    \t,set:(val)=>{\n    \t\tObject.defineProperty(window,'uniSoc',{value:val,enumerable:true,writable:true,configurable:true}); \n    \t\treturn val;\n    \t} \n    })\n}())\n\n\n//# sourceURL=webpack:///./build-web.js?");

/***/ }),

/***/ "./src/common.js":
/*!***********************!*\
  !*** ./src/common.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/uniSoc/uniSoc4.common.js\n//simpleSourceMap2=/lib/uniSoc/uniSoc4.common.js\n\n/*\n* @module uniSoc\n* @author plundell\n* @license Apache2\n* @description Unified API for various socket transports with question/answer protocol\n* \n* This class can be required in NodeJS by uniSoc.node.js or uniSoc.web.js, or it can be loaded \n* directly in the browser. If required it will export a function which should be called with the\n* dependencies, if loaded it expects the dependencies to be set on the global object prior to loading\n*\n* It provides the common bits of the uniSoc package used by both flavors (nodejs and browser)\n*\n* @depends BetterEvents\n* @depends BetterLog\n* @depends BetterUtil.common\n*\n* @exports function({dependencies}) \tIt exports a function which should be run with it's dependencies,\n*\t\t\t\t\t\t\t\t\t\twhich in turn returns the uniSoc_common constructor function\n*/\n;'use strict';\n\n\n\nmodule.exports=function export_uniSoc_common(dep={}){\n\n\tfunction missingDependency(which){throw new Error(\"Missing dependency for uniSoc: \"+which);}\n\tconst bu=dep.BetterUtil \t\t\t\t|| missingDependency('BetterUtil');\n\tconst BetterLog = dep.BetterLog         || missingDependency('BetterLog');\n\tconst BetterEvents = dep.BetterEvents   || missingDependency('BetterEvents');\n\n\n\tuniSoc.defaultOptions={\n\t\teom:'__EOM__' \t\t\t//A string that signifies the end of a message\n\t\t,transmitErrors:'all' \t//Should errors be transmitted? This affects the default .onerror callback. Accepted values are\n\t\t\t\t\t\t\t\t//  true|'all' => all errors passed unchanged, \n\t\t\t\t\t\t\t\t//  'toString' => transmit error.toString()\n\t\t\t\t\t\t\t\t//  'ifPrimitive' => transmit if error is a primitive value, else replace with 'Internal Error'\n\t\t\t\t\t\t\t\t//  false|'none' => change all errors to single string: 'error'\n\t\t\t\t\t\t\t\t//  'code' => only transmit the error code, defaulting to: 'error'\n\t\t\t\t\t\t\t\t//  function => will be set on this.onerror\n\t}\n\n\n/*2020-03-18: Instead of having this class rely in any way on the smart class, we've added 3 \"middleware\" oppertunities \n\t\t\t  to Client() (beforetransmit, aftertransmit, onresponse) which can be used by the smart class to do it's thing...\n\t\t\t  So now you'll have to setup each client to automatically send and receive smarties... */\n\t//Optionally you can pass in \"smart\" to enable builtin support for sending and receiving smart objects\n\t//that keep each other updated\n\t// if(dep.smart && typeof dep.smart=='object'){\n\t// \tif(!dep.smart.uniSoc||typeof dep.smart.uniSoc!='object'||typeof dep.smart.uniSoc.receive!='function'){\n\t// \t\tbu._log.warn(\"Bad optional dependency 'smart'. Expected object with structure: {uniSoc:{receive()}}\")\n\t// \t}else{\n\t// \t\tbu._log.debug(\"uniSoc: Smart objects in responses will be initiated automatically\")\n\t// \t\tuniSoc.receiveSmarty=dep.smart.uniSoc.receive;\n\t// \t}\n\t// }else{\n\t// \tbu._log.note(\"uniSoc: Not supporting automatic initiation of smart objects\");\n\t// }\n\n\n\n\n\t/*\n\t* @constructor \tuniSoc\tParent class for all uniSoc classes\n\t*\n\t* @param object \t\toptions\n\t*\n\t* @extends BetterEvents\n\t*\n\t*\n\t*\n\t* @prop number \tid \t\t\t\tUnique id integer, between 0-10,000,000\n\t* @prop <BetterLog> log\n\t* @prop object sentRequests\n\t* @prop object endpoints\n\t* @prop string EOM\n\t*\n\t* @prop function \thandler Can be changed at any time. Will be called with each new message\n\t*\t\t\t\t\t\t\t\t with args:\n\t*\t\t\t\t\t\t\t\t\tsubject - string\n\t*\t\t\t\t\t\t\t\t\tdata - any\n\t*\t\t\t\t\t\t\t\t\tcallback(err,response) - function\n\t*\n\t* @method send\n\t* @method request\n\t* ...\n\t*\n\t* @emit _working \tEmitted when this.receivedRequests becomes non-empty\n\t* @emit _waiting \tEmitted when this.receivedRequests becomes empty\n\t*\n\t* All uniSoc instances should implement\n\t*\n\t* @prop boolean connected \tSending is ok\n\t*\n\t* @emit _connect \t\tSending is now ok\n\t* @emit _disconnect \tSending is not ok any more\n\t*\n\t*/\n\tfunction uniSoc(options){\n\n\t\tif(typeof options=='string'){\n\t\t\toptions={name:options}\n\t\t}else if(typeof options!='object' || options.constructor.name!='Object'){\n\t\t\toptions={};\n\t\t}\n\t\toptions=Object.assign({},uniSoc.defaultOptions,this.constructor.defaultOptions,options);\n\n\n\t\t//For easy identification of a uniSoc (instanceof will fail if this constructor is loaded\n\t\t//multiple times, and you may not want to have to load uniSoc at all) \n\t\tObject.defineProperty(this,'isUniSoc',{value:true});\n\n\t\t/*\n\t\t* @prop number id \tA unique id for this instance\n\t\t*/\n\t\tObject.defineProperty(this,'id',{enumerable:true,value:options.id || Math.floor(Math.random()*10000000)})\n\t\t\n\n\t\tif(!options.name)\n\t\t\toptions.name=this.constructor.name+'_'+this.id;\n\n\t\t/*\n\t\t* @prop object options \n\t\t*/\n\t\tObject.defineProperty(this,'options',{enumerable:true,value:options})\n\n\t\t/*\n\t\t* @prop <BetterLog> log \n\t\t*/\n\t\tObject.defineProperty(this,'log',{value:new BetterLog(this,options)})\n\t\t\n\t\t//Inherit from BetterEvents and set failed emits to log to our log\n\t\tBetterEvents.call(this,{onerror:this.log.error});\n\n\n\t\t/*\n\t\t* @prop object endpoints \t\tKeys are string endpoint names (used when calling the endpoint over the \n\t\t*\t\t\t\t\t\t\t\tsocket, values are objects like: {args, description, listener, visible}.\n\t\t*/\n\t\tObject.defineProperty(this,'endpoints',{enumerable:true,value:{}})\n\n\n\t\t/*\n\t\t* @prop array sharedEndpoints\tContains objects like this.endpoints or other uniSoc instances\n\t\t*/\n\t\tObject.defineProperty(this,'sharedEndpoints',{enumerable:true,value:[]})\n\n\n\t\t/*\n\t\t* @prop function onerror \tWill be .call(this,payload) if we're about to transmit an error. Called after \n\t\t*\t\t\t\t\t\t\tpayload.data and payload.error have been awaited, but before this.beforetransmit\n\t\t*/\n\t\tif(typeof this.options.transmitErrors=='function'){\n\t\t\tthis.onerror=this.options.transmitErrors;\n\t\t}else{\n\t\t\tswitch(String(this.options.transmitErrors).toLowerCase()){\n\t\t\t\tcase 'tostring':\n\t\t\t\tcase 'string':\n\t\t\t\t\tthis.onerror=function errorToString(payload){payload.error=error.toString()};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'onlyprimitive':\n\t\t\t\tcase 'ifprimitive':\n\t\t\t\t\tthis.onerror=function passPrimitiveError(payload){\n\t\t\t\t\t\tif(bu.isPrimitive(payload.error)){\n\t\t\t\t\t\t\tpayload.error=this.log.makeError(payload.error);\n\t\t\t\t\t\t\tlet msg=`Sending 'Internal Error' as response to request ${payload.id}.`;\n\t\t\t\t\t\t\tif(payload.error.printed)\n\t\t\t\t\t\t\t\tthis.log.trace(msg);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tpayload.error.addHandling(msg).exec();\n\n\t\t\t\t\t\t\tpayload.error='Internal Error';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'none':\n\t\t\t\tcase false:\n\t\t\t\t\tthis.onerror=function passPrimitiveError(payload){\n\t\t\t\t\t\tpayload.error=this.log.makeError(payload.error);\n\t\t\t\t\t\tlet msg=`Sending 'error' as response to request ${payload.id}.`;\n\t\t\t\t\t\tif(payload.error.printed)\n\t\t\t\t\t\t\tthis.log.trace(msg);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpayload.error.addHandling(msg).exec();\n\t\t\t\t\t\tpayload.error='error';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t// case true:\n\t\t\t\t// case 'all':\n\t\t\t\t\tvar first=true;\n\t\t\t\t\tthis.onerror=function transmitErrors(payload){\n\t\t\t\t\t\t//payload.error has already been set to the error, and payload.data==null\n\t\t\t\t\t\tif(first){\n\t\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t\t\tthis.log.note(\"Remember, we are transmitting errors...\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\t/*\n\t\t* @prop function|null ontransmit \tWill be .call(this,payload) just before _transmit() is called\n\t\t*/\n\t\tthis.beforetransmit=null\n\n\t\t/*\n\t\t* @prop function|null aftertransmit \tWill be .call(this,payload) just after a successful _transmit()\n\t\t*/\n\t\tthis.aftertransmit=null\n\n\t\t/*\n\t\t* @prop function|null onresponse \tWill be .call(this,payload) on a successful response, just before passing\n\t\t*\t\t\t\t\t\t\t\t\tit on to the original caller (ie. the one waiting for the response)\n\t\t*/\n\t\tthis.onresponse=null\n\n\n\t\t//Register a single endpoint allowing opposite side to querey our endpoints\n\t\tthis.registerEndpoint('help',()=>Object.entries(this.listVisibleEndpoints())\n\t\t\t.map(([name,{args,description}])=>`${name}(${args})${description ? ' '+description:''}`).join('\\n')\n\t\t);\n\t\t\n\t}\n\tuniSoc.prototype=Object.create(BetterEvents.prototype); \n\tObject.defineProperty(uniSoc.prototype, 'constructor', {value: uniSoc}); \n\n\n\t/*\n\t* Close a socket/shutdown a server... ie. terminate whatever connection we're talking about\n\t*\n\t* NOTE: This method calls ._kill() which should be defined on all child classes\n\t*\n\t* @emit _disconnect \tEither from here, or from the respective _kill()\n\t*\n\t* @return Promise(void|BUGBUG) \tShould resolve when shutdown is complete\n\t*/\n\tuniSoc.prototype.close=\n\tuniSoc.prototype.disconnect=\n\tuniSoc.prototype.shutdown=\n\tuniSoc.prototype.terminate=\n\tuniSoc.prototype.kill=function(err){\n\t\tif(!(this instanceof uniSoc)){\n\t\t\tBetterLog._syslog.reject(\"BUGBUG: disconnect() called in non-instance scope, cannot disconnect. this:\",this);\n\t\t}else{\n\t\t\tif(!this.connected){\n\t\t\t\tif(!this.alreadyEmitted('_connect')){\n\t\t\t\t\tthis.log.info(\"Not yet connected, so won't emit _disconnect...\");\n\n\t\t\t\t}else if(!this.alreadyEmitted('_disconnect')){\n\t\t\t\t\tthis.log.warn(\"Possible EDGE CASE. .kill() was called, we're not connected, but _disconnect has not been emitted. Doing so now...\")\n\t\t\t\t\tthis.emit('_disconnect',err);\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve();\n\t\t\t} else if(typeof this._kill=='function') {\n\t\t\t\tthis.log.trace(\"Going to close socket...\")\n\n\t\t\t\t//2019-11-05: I think we should let each class listen for it's own events and set this\n\t\t\t\t// try{this.connected=false;}catch(err){} //we might have a getter in place, in which case that takes presidence\n\t\t\t\t\n\t\t\t\treturn Promise.resolve(this._kill())\n\t\t\t\t\t.catch(this.log.error) //errors from the _kill function, not the error passed in here^\n\t\t\t\t\t.then(()=>{this.emitOnce('_disconnect',err);}); //Only emit once\n\t\t\t}else{\n\t\t\t\treturn this.log.reject(\"BUGBUG: no disconnect function set\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Register a listener $func that is called if this uniSoc receives a message with $subject. Args are \n\t* passed to $func either based on name (if available, see $options.argNames) or order. \n\t*\n\t* NOTE: $func can get custom access by using the following reserved arg names:\n\t*\t\t'callback' - the error-first callback that sends the response to the sender\n\t*\t\t'payload' - the live object that was received and will eventually be returned to sender\n\t*\t\t'unisoc' - the receiveing unisoc (which may differ from the one the endpoint was registered on)\n\t*  \n\t* NOTE: if reserved name 'callback' is NOT used then whatever $func returns will be returned to sender\n\t* \n\t* @param string \tsubject\n\t* @paran function \tfunc    \tA function that will be called with \n\t* @param object \toptions \tAvailable: \n\t*\t\t\t\t\t\t\t\t\targNames(array)\n\t*\t\t\t\t\t\t\t\t\treqArgCount(number)\n\t*\t\t\t\t\t\t\t\t\tcallAs(object)\n\t*\t\t\t\t\t\t\t\t\tsecret(boolean)\n\t*\n\t* @stores object {args, description, listener, visible} => this.endpoints{}\n\t*\n\t* @return string \t\t$subject, used eg by registerEndpointsForObject()\n\t*/\n\tuniSoc.prototype.registerEndpoint=function registerEndpoint(subject,func,options={}){\n\t\ttry{\n\t\t\tvar self=this;\n\t\t\tbu.checkTypes(['string','function','object'],[subject,func,options]);\n\n\t\t\t//Unlike events, only a single endpoint may be registered\n\t\t\tif(this.hasEndpoint(subject,'localOnly'))\n\t\t\t\tthrow \"EEXISTS\"\n\n\n\t\t\t//Try to get names of args. This will not work if function has been bound is is native in which case it\n\t\t\t//will not be possible to call endpoint with object containing named args\n\t\t\tvar argNames=options.argNames || func._argNames\n\t\t\tif(!argNames){\n\t\t\t\ttry{\n\t\t\t\t\targNames=bu.getArgNames.call(this,func,true); //true==show default values\n\t\t\t\t}catch(err){\n\t\t\t\t\tlog.warn(`Endpoint '${subject}' will not support named args.`,err);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar reqArgCount=func._length|| func.length; //number of args without default values\t\t\t\t\t\t\n\n\t\t\t//Initiate object that will be stored on this.endpoints and start populating it\n\t\t\tvar ep={};\n\t\t\tif(Array.isArray(argNames)){\n\t\t\t\t//Remove the 'reserved args' from those that will be listable \n\t\t\t\targNames=bu.filterSplit(argNames,arg=>arg.match(/(callback|payload|unisoc)/)==null,'retainIndex');\n\n\t\t\t\tep.args=Object.values(argNames).join(', ');\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t//With named args the options.reqArgCount is ignored...\n\t\t\t\treqArgCount-=Object.values(argNames.rest).length;\n\t\t\t}else{\n\t\t\t\t//...but if no named args exists, it's not ignored\n\t\t\t\tep.args=reqArgCount=options.reqArgCount || func._reqArgCount|| reqArgCount;\n\t\t\t\targNames=false;\n\t\t\t}\n\t\n\n\t\t\t//Same with optional description\n\t\t\tlet d=options.description||func._description\n\t\t\tif(typeof d=='string')\n\t\t\t\tep.description=d\n\n\t\t\t/*\n\t\t\t* Listener method that gets called by this.handler(). It parses the args received in the\n\t\t\t* request, possibly appends the reserved ones (payload|callback|unisoc) then calls $func.\n\t\t\t*\n\t\t\t* @param object payload \t\t\tThe entire received 'payload'.\n\t\t\t* @opt function callback \t\t\tThis is the function bound in/by receive() IF we received a request (as\n\t\t\t*\t\t\t\t\t\t\t\t\t\topposed to a message that doesn't want a response)\n\t\t\t*\n\t\t\t* @return void\n\t\t\t* @call(receiving unisoc)\n\t\t\t*/\n\t\t\tep.listener=function endpointListener(payload,callback){\n\t\t\t\t// self.log.traceFunc(arguments);\n\t\t\t\ttry{\n\t\t\t\t\tvar argsArr\n\t\t\t\t\t\t,p\n\t\t\t\t\t\t,ignoreReturn=false\n\t\t\t\t\t\t,entry=this.log.makeEntry('note',`${payload.id}: Calling endpoint: ${subject}`);\n\t\t\t\t\t;\n\t\t\t\t\tswitch(bu.varType(payload.data)){\n\t\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t//NOTE: if you need to pass an object as the single expected arg, then wrap it in an array\n\t\t\t\t\t\t\targsArr=payload.data;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif(!argNames)\n\t\t\t\t\t\t\t\tthis.log.makeError(\"This endpoint doesn't support named args. Try consulting docs...\").throw('EINVAL');\n\n\t\t\t\t\t\t\targsArr=argNames.map(name=>payload.data[name])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'null':\n\t\t\t\t\t\t\targsArr=[payload.data];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'undefined':\n\t\t\t\t\t\t\targsArr=[];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis.log.makeError(\"BUGBUG: unexpected payload.data: \",bu.logVar(payload.data)).throw('EINVAL');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Now make sure we have enough non-reserved args\n\t\t\t\t\tif(argsArr.length<reqArgCount)\n\t\t\t\t\t\tthis.log.makeError(`Command requires ${reqArgCount} args minimum, only got ${argsArr.length}.`)\n\t\t\t\t\t\t\t.throw('EINVAL');\n\n\t\t\t\t\t//If any reserved args where requested, set them on the argsArr where appropriate (overwriting\n\t\t\t\t\t//anything possibly set ^)\n\t\t\t\t\tif(argNames && argNames.rest.length){\n\t\t\t\t\t\targNames.rest.forEach((name,i)=>{\n\t\t\t\t\t\t\tswitch(name){\n\t\t\t\t\t\t\t\tcase 'callback':\n\t\t\t\t\t\t\t\t\tif(typeof callback=='function'){\n\t\t\t\t\t\t\t\t\t\tignoreReturn=true;\n\t\t\t\t\t\t\t\t\t\tentry.addHandling(\"Including response callback. If it's not called, then no response will be sent\");\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tentry.lvl=5;\n\t\t\t\t\t\t\t\t\t\tentry.addHandling(\"option.callback being ignored because no response requested\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\targsArr[i]=callback;\n\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\tcase 'payload':\n\t\t\t\t\t\t\t\t\tentry.addHandling(\"Including live payload. You can set additional props on it before sending\")\n\t\t\t\t\t\t\t\t\targsArr[i]=payload;\n\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\tcase 'unisoc':\n\t\t\t\t\t\t\t\t\tentry.addHandling(\"Including receiving uniSoc\");\n\t\t\t\t\t\t\t\t\targsArr[i]=this;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\n\t\t\t\t\tentry.extra.push('( '+(argsArr.length ? argsArr.map(x=>bu.logVar(x,50)).join(', ') : '<void>')+' )' )\n\t\t\t\t\tentry.exec();\n\n\t\t\t\t\tp=bu.applyPromise(func,argsArr,options.callAs)\n\n\t\t\t\t}catch(err){\n\t\t\t\t\terr=this.log.makeError(err);\n\t\t\t\t\tif(err.code=='EINVAL'){\n\t\t\t\t\t\terr.exec(); //print here...\n\t\t\t\t\t\tp=Promise.reject(err.toString()); //...but also send msg over socket as string\n\t\t\t\t\t}else{\n\t\t\t\t\t\tp=err.reject(); //these will get caught in preparePayload(), logged there, and InternalError sent over socket\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar who=(payload.id?payload.id+': ':''),log=this.log\n\t\t\t\tif(typeof callback=='function'){ //this is the callback created in receive()\n\t\t\t\t\t//RESPONSE EXPECTED\n\t\t\t\t\tif(argNames && argNames.rest.includes('callback')){\n\t\t\t\t\t\t//If you've asked for the callback then it's up to you to call it if you want something sent, error or success\n\t\t\t\t\t\t//Uncaught errors get logged vv\n\t\t\t\t\t}else{\n\t\t\t\t\t\tp=p.then(\n\t\t\t\t\t\t\tfunction respondingWithData(data){callback(null,data)}\n\t\t\t\t\t\t\t,function respondingWithError(err){callback(err)}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tp.catch(function responseCallbackError(e){log.error(`${who}Failed to return request reponse`,e)});\n\t\t\t\t}else{\n\t\t\t\t\t//NO RESPONSE\n\t\t\t\t\tp.then(\n\t\t\t\t\t\tfunction respondingWithData(data){\n\t\t\t\t\t\t\t(typeof data!='undefined')\n\t\t\t\t\t\t\t\t&&log.note(`${who}Endpoint returned data but none was expected:`,data)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t,function endpointFunctionError(err){log.error(`${who}Endpoint call failed.`,err)}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Now we're going to add the listener to the endpoint event, but first the option to make it \n\t\t\t//\"secret\", ie. so it doesn't show up with 'help'. Obviously this just makes it secret\n\t\t\t//for anyone who doesn't have access to this object, like the other side of the socket\n\t\t\tep.visible=options.secret?false:true;\n\t\t\tthis.endpoints[subject]=ep\n\t\t\tthis.log.debug(`Added ${options.secret ? 'secret ':''}endpoint: ${subject}(${ep.args})`);\n\n\t\t\treturn subject;\n\t\t\t\n\t\t}catch(err){\n\t\t\t// console.log(this);\n\t\t\tthrow this.log.error(\"Failed to register method:\",subject,err);\n\t\t}\n\t}\n\n\n\n\n\n\n\t/*\n\t* Get an endpoint from those registered locally and those extendedn from other sources\n\t*\n\t* @param string subject\n\t* @opt boolean localOnly \tDefault false. If true only locally registered endpoints will be returned\n\t*\n\t* @throw TypeError \tIf $subject isn't a string\n\t*\n\t* @return object{listener,args,description}|undefined\n\t*/\n\tuniSoc.prototype.getEndpoint=function(subject,localOnly=false){\n\t\t// this.log.traceFunc(arguments);\n\t\tbu.checkType('string',subject)\n\n\t\ttry{\n\t\t\tvar ep,source;\n\t\t\tif(this.endpoints.hasOwnProperty(subject)){\n\t\t\t\tsource='local';\n\t\t\t\tep=this.endpoints[subject];\n\t\t\t}else if(!localOnly){\n\t\t\t\tfor(var i in this.sharedEndpoints){\n\t\t\t\t\tlet obj=this.sharedEndpoints[i];\n\t\t\t\t\tif(typeof obj.getEndpoint=='function'){\n\t\t\t\t\t\tsource='shared'+(obj.isUniSoc?' (from '+obj.options.name:'(function')+')';\n\t\t\t\t\t\tep=obj.getEndpoint(subject); //Remember, the other unisoc will traverse down it's tree of shared endpoints\n\t\t\t\t\t}else if(obj.hasOwnProperty(subject)){\n\t\t\t\t\t\tsource='shared'\n\t\t\t\t\t\tep=obj[subject];\n\t\t\t\t\t}\n\t\t\t\t\tif(ep)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ep){\n\t\t\t\t//Just in case something went wrong or someone has been messing\n\t\t\t\t//with the endpoints manually...\n\t\t\t\tif(typeof ep!='object' || typeof ep.listener!='function'){\n\t\t\t\t\tthis.log.error(`Unexpected ${source} endpoint '${subject}'. Got:`,bu.logVar(ep));\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// this.log.trace('Returning:',ep);\n\t\t\treturn ep; //can be undefined\n\t\t}catch(err){\n\t\t\tthis.log.error(`BUGBUG: Failed to get endpoint '${subject}'`,err,{ep,source});\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/*\n\t* Get all visible endpoints for this object. Used to display help\n\t* @return object \tKeys are endpoint subjects, values are objects with \n\t*/\n\tuniSoc.prototype.listVisibleEndpoints=function(){\n\t\t//First get local visible endpoints...\n\t\tvar endpoints=bu.subObj(this.endpoints,(subject,obj)=>obj.visible);\n\n\t\t//Then look through our shared endpoints\n\t\tthis.sharedEndpoints.forEach(x=>{\n\t\t\tvar subject, shared = (typeof x.listVisibleEndpoints=='function' ? x.listVisibleEndpoints() : x);\n\t\t\tfor(subject in shared){\n\t\t\t\tif(shared[subject].visible && !endpoints.hasOwnProperty(subject))\n\t\t\t\t\tendpoints[subject]=shared[subject];\n\t\t\t}\n\t\t\t\n\t\t})\n\t\treturn endpoints;\n\t}\n\n\n\t/*\n\t* Check if and endpoint or secret endpoint exists\n\t*\n\t* @param string subject\n\t*\n\t* @return boolean\n\t*/\n\tuniSoc.prototype.hasEndpoint=function(subject,localOnly){\n\t\treturn this.getEndpoint(subject,localOnly) ? true : false;\n\t}\n\n\n\n\n\t/*\n\t* Remove an endpoint or secret endpoint\n\t*\n\t* @param string endpoint\n\t*\n\t* @return void\n\t*/\n\tuniSoc.prototype.unregisterEndpoint=function(subject){\n\t\tdelete this.endpoints[subject]\n\t\treturn;\n\t}\n\n\n\n\n\t/*\n\t* Add shared endpoints to this uniSoc\n\t*\n\t* @param <uniSoc>|object endpoints \tA regular object containing multiple named endpoint objects (eg. this.endoints) \n\t*\t\t\t\t\t\t\t\t\tor another uniSoc instance\n\t* @return void\n\t*/\n\tuniSoc.prototype.registerSharedEndpoints=function(endpoints){\n\t\tbu.checkType('object',endpoints);\n\n\t\tif(typeof endpoints.getEndpoint=='function'&&typeof endpoints.listVisibleEndpoints=='function'){\n\t\t\tif(!this.sharedEndpoints.includes(endpoints))\n\t\t\t\tthis.sharedEndpoints.push(endpoints);\n\t\t}else{\n\t\t\t//If we get a regular object, then only the endpoints that exist now are added\n\t\t\tvar clean={},ep;\n\t\t\tfor(ep in endpoints){\n\t\t\t\tif(endpoints[ep].hasOwnProperty('listener')){\n\t\t\t\t\tclean[ep]=bu.extract(endpoints[ep],['listener','description','args','visible']);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.sharedEndpoints.push(clean);\n\t\t}\n\t\treturn;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Register endpoints for all enumerable methods and props on an object\n\t*\n\t* @param object obj \t  \t\t\tAny object\n\t* @param string prefix \t  \t\t\tA string to use as first part of endpoint (will be surrounded by '/')\n\t* @param object options \t\t\tOptions for this method + for registerEndpoint(). Props '_all' will be\n\t*\t\t\t\t\t\t\t\t\t passed to all registers, and keys matching each endpoint will be sent\n\t*\t\t\t\t\t\t\t\t\t to each register individually\n\t*\n\t* @throws <BLE_TypeError>\n\t*\n\t* @return array [string]  List of all the registered endpoints\t\t\n\t*/\n\tuniSoc.prototype.registerEndpointsForObject=function(obj,prefix,options={}){\n\t\tbu.checkTypes(['object','string','object'],[obj,prefix,options]);\n\n\t\t//Decide which props to register and which to ignore\n\t\tvar ignore=[], props=Object.keys(obj);\n\t\tif(Array.isArray(options.ignore)){\n\t\t\tprops=props.filter(key=>{\n\t\t\t\tif(options.ignore.indexOf(key)>-1){\n\t\t\t\t\tignore.push(key)\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\t\n\t\tif(!props.length){\n\t\t\tthis.log.warn(\"No props are going to be registered from: \",obj);\n\t\t\treturn [];\n\t\t}\n\t\tthis.log.debug(\"Registering props as endpoints: \"+props.join(',')\n\t\t\t+(ignore.length?'. Ignoring these: '+ignore.join(','):''))\n\n\t\tvar list=[];\n\t\tprops.forEach(prop=>{\n\t\t\t//Build options\n\t\t\tvar opts=Object.assign({callAs:obj},options._all,options[prop]);\n\n\t\t\tvar ep=`/${prefix}/${prop}`;\n\t\t\tif(typeof obj[prop]=='function'){\n\t\t\t\tlist.push(this.registerEndpoint(ep,obj[prop],opts))\n\t\t\t}else{\n\t\t\t\tvar desc=Object.getOwnPropertyDescriptor(obj,prop);\n\t\t\t\tif(desc.hasOwnProperty('value')){\n\t\t\t\t\tlist.push(this.registerEndpoint(`${ep}/get`,function get(){return obj[prop];},opts));\n\t\t\t\t\tif(desc.writable){\n\t\t\t\t\t\tlist.push(this.registerEndpoint(`${ep}/set`,function set(val){return obj[prop]=val;},opts));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(desc.get){\n\t\t\t\t\t\tlist.push(this.registerEndpoint(`${ep}/get`,desc.get,opts));\n\t\t\t\t\t}\n\t\t\t\t\tif(desc.set){\n\t\t\t\t\t\tlist.push(this.registerEndpoint(`${ep}/set`,desc.get,opts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\treturn list;\n\t}\n\n\n\t/*\n\t* Reverse registerEndpointsForObject() to produce an object with methods/setter/getter. \n\t*\n\t* @param array[string] endpoints \t\n\t*\n\t* @return object \n\t*/\n\tuniSoc.prototype.createProxyFromEndpoints=function(endpoints){\n\t\tbu.checkType('array',endpoints);\n\t\tvar proxy={};\n\t\tendpoints.forEach(ep=>{\n\t\t\ttry{\n\t\t\t\t//We expect ep to be a '/' delimited string with a prefix followed by either method name or \n\t\t\t\t//prop+get/set, eg. \t\t\t\t\t\t--prefix-- \t\t\t--method/prop--   --get/set--\n\t\t\t\t//\t\t/prefix1/method1 \t\t\t=>   ['','prefix1',\t\t\t\t'method1']\n\t\t\t\t//\t\t/prefix1/method2 \t\t\t\n\t\t\t\t//\t\t/multipre/fix2/method1\t\t=>   ['','multipre','fix2',\t\t'method1']\n\t\t\t\t//\t\t/multipre/fix2/prop1/get\n\t\t\t\t//\t\t/multipre/fix2/prop2/get \t=>   ['','multipre','fix2',\t\t'prop2',\t\t'get']\n\t\t\t\t//\t\t/multipre/fix2/prop2/set\n\t\t\t\t//\n\t\t\t\t// Which we will set on the above created proxy object like so:\n\t\t\t\t// \t{\n\t\t\t\t// \t\t\"/prefix1:{\n\t\t\t\t//\t \t\tmethod1:function()\n\t\t\t\t//\t \t\t,method2:function()\n\t\t\t\t//\t \t}\n\t\t\t\t//\t \t\"/multipre/fix2\":{\n\t\t\t\t//\t \t\tmethod1:function()\n\t\t\t\t//\t\t\t,prop1:getter()\n\t\t\t\t//\t\t\t,prop2:getter(),setter()\n\t\t\t\t//\t \t}\n\t\t\t\t//\t }\n\t\t\t\tvar arr=ep.split('/');\n\n\t\t\t\t//Since we always use prefix when creating endpoints from objects, so the non-existence of one \n\t\t\t\t//means this ep has slipped in here by mistake\n\t\t\t\tif(arr.length<2)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar prop=arr.pop(),gs=false;\n\t\t\t\tif(prop=='set' || prop=='get'){\n\t\t\t\t\tgs=prop;\n\t\t\t\t\tprop=arr.pop();\n\t\t\t\t}\n\n\t\t\t\tif(!prop){\n\t\t\t\t\tthis.log.warn(\"Unexpected endpoint, skipping:\",ep);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet prefix=arr.join('/'); \n\t\t\t\tif(!proxy.hasOwnProperty(prefix))\n\t\t\t\t\tproxy[prefix]={}\n\n\t\t\t\tif(gs=='set')\n\t\t\t\t\t//configurable since get/set are seperate endpoints and as such the property may need updating\n\t\t\t\t\tObject.defineProperty(proxy[prefix],prop,{enumerable:true,configurable:true,set:(val)=>this.request(ep,val)})\n\t\t\t\telse if(gs=='get')\n\t\t\t\t\tObject.defineProperty(proxy[prefix],prop,{enumerable:true,configurable:true,get:()=>this.request(ep)})\n\t\t\t\telse{\n\t\t\t\t\tObject.defineProperty(proxy[prefix],prop,{enumerable:true\n\t\t\t\t\t\t,value:(...args)=>this.request(ep,args.length ? args:undefined)});\n\t\t\t\t}\n\t\t\t}catch(err){\n\t\t\t\tthis.log.error(`Failed to add endpoint ${ep}' to proxy obj.`,err);\n\t\t\t}\n\t\t})\n\n\t\treturn proxy;\n\t}\n\n\n\n\n\n\n\n\n\n\n\tuniSoc.prototype.getRemoteEndpoints=function(){\n\t\treturn this.request('help');\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Common constructor for all uniSoc items that are clients (ie. only uniSoc_Server does NOT\n\t* inherit from this)\n\t*/\n\tfunction uniSoc_Client(options){\n\t\tuniSoc.call(this,options);\n\n\t\t/*\n\t\t* @prop object \tsentRequests \tKeys are numerical id's requests we've sent, values are \n\t\t*\t\t\t\t\t\t\t\tcallback functions for when responses arrive. \n\t\t*\n\t\t* NOTE: Children will be deleted when responses arrive\n\t\t*/\n\t\tObject.defineProperty(this,'sentRequests',{enumerable:true,value:{}})\t\n\t\t\n\t\t/*\n\t\t* @method sentRequests.length \tThe number of requests we're waiting for answers on\n\t\t*/\n\t\tObject.defineProperty(this.sentRequests,'length',{get:()=>Object.keys(this.sentRequests).length});\n\n\t\t/*\n\t\t* @prop object receivedRequests\tKeys are numerical id's of requests we've received and are \n\t\t*\t\t\t\t\t\t\t\tcurrently working on a response for, values are callback \n\t\t*\t\t\t\t\t\t\t\tfunctions that will answer them.\n\t\t*\n\t\t* NOTE: Props will be deleted when responses are sent\n\t\t*/\n\t\tObject.defineProperty(this,'receivedRequests',{enumerable:true,value:{}})\t\n\n\t\t/*\n\t\t* @method receivedRequests.length \tThe number of requests we're currently working on and are \n\t\t*\t\t\t\t\t\t\t\t\tultimately going to respond to\n\t\t*/\n\t\tObject.defineProperty(this.receivedRequests,'length',{get:()=>Object.keys(this.receivedRequests).length});\n\n\n\n\t\t//Set the default EOM which should usually work... but maybe for some reason we need to change it\n\t\t//to work with some external client or something...\n\t\tObject.defineProperty(this,'EOM',{writable:true,enumerable:false, value:options.eom})\n\t}\n\tuniSoc_Client.prototype=Object.create(uniSoc.prototype); \n\tObject.defineProperty(uniSoc_Client.prototype, 'constructor', {value: uniSoc_Client}); \n\n\n\n\n\n\n\n\t/*\n\t* Parse args passed to send(...args) or request(...args)\n\t*\n\t* @param array[subject, data..., callback] \t\t\n\t*\t- OR -\n\t* @param array[object{subject,data,callback,timeout, expResCount}] \t\t\n\t*\n\t* NOTE: the later ^ can accept more args\n\t* \n\t* @return object \tAn object with named args\n\t* @no_instance\n\t*/\n\tuniSoc.prototype.parseArgs=function(args){\n\t\tif(args.length==1 && typeof args[0]=='object' && args[0].hasOwnProperty('subject'))\n\t\t\t//This object can contain more params then vv\n\t\t\tvar obj=args[0];\n\t\telse\n\t\t\tobj={\n\t\t\t\tcallback:bu.getFirstOfType(args,'function',true)\n\t\t\t\t,subject:args.shift() //first non-function is the subject\n\t\t\t\t,data:(args.length==1 ? args[0] : !args.length ? undefined : args) //everything else is the data\n\t\t\t}\n\n\t\treturn obj\n\t}\n\n\n\t/*\n\t* Each _transmit() function should call this method\n\t*\n\t* @return true|Promise.reject(<BetterLogEntry [not logged]>) \t\n\t*/\n\tuniSoc_Client.prototype.afterTransmit=function(err,payload,address,port){\n\t\tvar fail='Failed to transmit';\n\t\tif(err && err.toString().match(fail)) //so we don't double up\n\t\t\treturn this.log.makeEntry(err).reject();\n\n\t\tvar id='',what=(payload.subject=='__uniSoc_response'?'response':'message')\n\t\tif(payload.id){\n\t\t\tif(this.sentRequests[payload.id]){\n\t\t\t\twhat='request'\n\t\t\t}\n\t\t\tid=payload.id+': ';\n\t\t}\n\t\tif(address||port)\n\t\t\twhat+=` to ${address||''}:${port||''}`\n\n\t\tif(err)\n\t\t\treturn this.log.makeError(`${fail} ${what}:`,err).reject();\n\t\telse{\n\t\t\tthis.log.info(`${id}Successfully sent ${what}:`\n\t\t\t\t,'subject: '+(payload.target||payload.subject)+'\\n' //\\n=>all extra on own line\n\t\t\t\t,'error: '+bu.logVar(payload.error)\n\t\t\t\t,'data: '+bu.logVar(payload.data)\n\t\t\t)\n\t\t\t\n\t\t\t//In case we want to apply futher handling to all successfully transmitted messages, here's the chance\n\t\t\tif(typeof this.aftertransmit=='function'){\n\t\t\t\tthis.aftertransmit.call(this,payload);\n\t\t\t}\n\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\n\t/*\n\t* Send a new message without expecting a response\n\t*\n\t* @params @see parseArgs()\n\t*\n\t* @return Promise \t\t\t\tResolves/rejects if sending succeeded\n\t*/\n\tuniSoc_Client.prototype.send=function send(...args){\n\t\tvar {_transmit,...payload}=this.parseArgs.call(this,args); //doesn't really need 'this', but firefox doesn't seem to like call(null,...)\n\t\t\n\t\tif(!this.connected){\n\t\t\tthis.disconnect('EPIPE'); //Make sure the client gets removed from the server\n\t\t\treturn this.log.makeError('Socket is not open, failed to send...').setCode('EPIPE').reject();\n\t\t}\n\n\t\treturn preparePayload.call(this,payload)\n\t\t\t.then(payload=> _transmit?_transmit(payload):this._transmit(payload)) //the _transmit() method should log\n\t\t;\n\t}\n\n\t/*\n\t* Send a new message that expects a response\n\t*\n\t* @params @see parseArgs()\n\t* \t@opt function callback \tCalled with response error or success. Not called if sending fails. Affects what\n\t*\t\t\t\t\t\t\tthis method returns.\n\t*\n\t* @return Promise \t\tAlways rejects if sending fails. Resolve depends on $callback:\n\t*\t\t\t\t\t\t\tIf passed: it resolves when sending succeedes with id (used to unregister request). \n\t*\t\t\t\t\t\t\tIf omitted: resolves/rejects with the response from the other side of the socket.\n\t*/\n\tuniSoc_Client.prototype.request=function request(...args){\n\t\tvar {callback,timeout,_transmit,...payload}=this.parseArgs.call(this,args);\n\t\t\n\t\tif(!this.connected){\n\t\t\tthis.disconnect('EPIPE'); //Make sure the client gets removed from the server\n\t\t\treturn this.log.makeError('Socket is not open, failed to send...').setCode('EPIPE').reject();\n\t\t}\n\t\t\n\t\tvar [id,promise,onSendSuccess,onSendError]=prepareRequest.call(this,callback,timeout);\n\t\tpayload.id=id; //this id is was identfies the msg as a request() and not a send()\n\n\n\t\t//The following chain will always resolve (so no need to do anything with it)...\n\t\tpreparePayload.call(this,payload)\n\t\t\t.then(payload=>_transmit?_transmit(payload):this._transmit(payload))\n\t\t\t.then(onSendSuccess,onSendError)\n\n\t\t//...but it will affect the returned promise\n\t\treturn promise;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Prepare a payload to be sent via uniSoc, mainly by waiting for promises to resolve and making\n\t* sure no Error objects get transfered\n\t*\n\t* @param object payload \tObject which contains props (all but the first are optional):\n\t*\t\t\t\t\t\t\t\tstring subject \t\t\t\n\t*\t\t\t\t\t\t\t\tany data \t\t\t\tAny data to be transfered\n\t*\t\t\t\t\t\t\t\tstring|number error \tInstances of Error will be replaced by string 'Internal Error\n\t*\t\t\t\t\t\t\t\tnumber id \t\t\t\tIf omitted, 0 will be used, which indicates that no response\n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t  is expected \n\t* @reject <ble TypeError> \tpayload is not object\n\t* @reject <ble EINVAL> \t\tpayload.subject is invalid\n\t*\n\t* @resolve obj \t\tResolves with the payload ready to be sent (ie. all promises resolved and preparation callbacks made)\n\t*\n\t* @call(<uniSoc_Client>)\n\t* @async\n\t*/\n\tasync function preparePayload(payload){\n\t\ttry{\n\n\t\t\t//Then we start checking we got the right things\n\t\t\tbu.checkType('object',payload);\n\n\t\t\t//Make sure we have a string subject that does not contain the word 'undefined', because that is \n\t\t\t//most likely an error when dynamically creating the subject\n\t\t\tif(typeof payload.subject!='string')\n\t\t\t\tthis.log.makeError('A string subject is required, got:',bu.logVar(payload.subject)).throw('EINVAL');\n\t\t\tif(payload.subject.includes('undefined'))\n\t\t\t\tthis.log.makeError('Illegal subject contained the string \"undefined\": '+payload.subject).throw('EINVAL');\n\n\n\t\t\t//Mark the object as uniSoc, so we can identify it in certain cases where other things\n\t\t\t//may be transmitted on the same socket\n\t\t\tpayload.__uniSoc=true;\n\n\t\t\t//Make sure we have an id, >0 if this is the response to a request, else 0 which implies\n\t\t\t//that we're sending something and not expecting a response\n\t\t\tpayload.id=typeof payload.id=='number' ? payload.id : 0\n\n\n\t\t\t//Await the data and error, and if anything goes wrong it's the same as if an error was passed\n\t\t\ttry{\n\t\t\t\tpayload.error=await payload.error; \n\t\t\t\tpayload.data=await payload.data;\n\t\t\t}catch(error){\n\t\t\t\tpayload.error=error;\n\t\t\t}\n\n\n\t\t\t//If we have an error now (passed or caught ^, it's all the same)...\n\t\t\tif(payload.error){\n\t\t\t\t//...we make sure there's not data as well...\n\t\t\t\tif(payload.data){\n\t\t\t\t\tlet msg=\"Got data and error. Sending the error and discarding\"\n\t\t\t\t\tif(bu.varType(payload.data)=='promise'){\n\t\t\t\t\t\t//Don't wait for data to resolve... just log now and then again on resolve\n\t\t\t\t\t\tlet ble=this.log.makeEntry('warn',msg+\" promised data (see later log)\").exec();\n\t\t\t\t\t\tpayload.data\n\t\t\t\t\t\t\t.then(data=>this.log.warn(`Discarded data from entry #${ble.id}:`,data))\n\t\t\t\t\t\t\t.catch(err=>this.log.warn(`Discarded promise from entry #${ble.id} rejected:`,err))\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis.log.warn(msg+\" this data:\",payload.data);\n\t\t\t\t\t}\n\t\t\t\t\tpayload.data=null;\n\t\t\t\t}\n\n\t\t\t\t//...and we call the handler, set either in the constructor or at any later point. It can do whatever\n\t\t\t\t//it wants with the payload...\n\t\t\t\tthis.onerror(payload);\n\t\t\t}\n\n\t\t\t//F.Y.I what get's included when sending...\n\t\t\t//  JSON.stringify({data:undefined}) => '{}'  \t\t\n\t\t\t//  JSON.stringify({data:null}) => '{\"data\":null}' \n\n\t\t\t//In case we want to apply futher handling to all payloads, here's the chance\n\t\t\tif(typeof this.beforetransmit=='function'){\n\t\t\t\tthis.beforetransmit.call(this,payload);\n\t\t\t}\n\n\t\t\tthis.log.makeEntry('debug','Payload ready:',payload).addHandling(\"next step is transmitting...\").exec();\n\n\n\t\t\treturn payload;\t\t\t\t\t\t\t\t\n\t\t\t  //^ remember, async func, this will be returned in a resolved promise\n\t\t}catch(err){\n\t\t\treturn this.log.makeError('Failed to prepare payload',err).reject()\n\t\t}\n\n\t}\n\n\n\n\t/*\n\t* Prepare a callback for a request\n\t*\n\t* @opt @anyorder function responseCallback \tCalled with each (ie. possibly multiple) resopnses with args (err,data,obj).\n\t* @opt @anyorder number timeout  \t\t\tms until request failes with 'timeout' error. Default 0 == infinite\n\n\t* NOTE: If @responseCallback isn't passed, only a single response is accepted, else responses will keep being accepted\n\t*\t\t until you call this.cancelRequest() with the id (see @return vv) or @responseCallback itself \n\t* NOTE2:The 3rd arg passed to @responseCallback is the entire received uniSoc-formated object. It IS NOT available\n\t*\t\t in the resolved promise if you omit @resopnseCallback\n\t*\n\t* @return array [ \t\t\tReturns an array with the 4 following items:\n\t*\t\tnumber \t\t\t\t\tThe id of the request (passed on to preparePayload() by request())\n\t*\t\t,Promise \t\t\t\tThe promise to be returned by request(). Rejects if sending fails. If $responseCallback is\n\t*\t\t\t\t\t\t\t\t  passed it resolves when sending succeedes with id (used to unregister request). Else  it \n\t*\t\t\t\t\t\t\t\t  resolves/rejects with the response from the other side of the socket.\n\t*\t\t,callback(err) \t\t\tCallback to be used on send error\n\t*\t\t,callback \t\t\t\tCallback to be used on send success (only if @responseCallback was passed in)\n\t*\t] \t\n\t*\n\t* @call(<uniSoc_Client>)\n\t*/\n\tfunction prepareRequest(responseCallback=undefined,timeout=0){\n\n\t\t// Start by generating an id used to identify the response when it comes\n\t\tvar id=Math.floor(Math.random()*1000000000)+1; //+1 we we don't get 0 \n\t\t// console.log(this);\n\t\twhile(typeof this.sentRequests[id]!=='undefined'){\n\t\t\tid+=1;\n\t\t}\n\t\tvar logStr=`Built request (${id}), response via `;\n\n\n\t    //For logging purposes in web, we want to avoid anon functions....\n\t    var self=this;\n\t\t\n\t\tif(typeof responseCallback=='function'){\n\t\t\tlogStr+='callback'\n\t\t\tvar {resolve:onSendSuccess,reject:onSendError,promise:sendPromise}=bu.exposedPromise();\n\t\t\t\n\t\t\t//Logging has already been done by send, just change what's returned on success and make\n\t\t\t//sure to unregister on failed send\n\t\t\tsendPromise=sendPromise.then(\n\t\t\t\t()=>id\n\t\t\t\t,function failedToSendRequest(err){\n\t\t\t\t\tself.cancelRequest(id);\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t//Unlike vv where a timeout will fail an outstanding request, here it merely\n\t\t\t//unregisters the request as a means of convenience\n\t\t\tif(timeout){\n\t\t\t\tlogStr+=`, active for ${timeout} ms`\t\t\t\n\t\t\t\tsetTimeout(()=>{\n\t\t\t\t\tif(this.sentRequests[id]){\n\t\t\t\t\t\tthis.log.debug(`Request ${id} timed out after ${timeout} ms.`);\n\t\t\t\t\t\tthis.cancelRequest(id);\n\t\t\t\t\t}\n\t\t\t\t},timeout)\n\t\t\t}\n\n\t\t} else {\n\t\t\tlogStr+='promise'\n\t\t\tvar {reject:requestFailed,promise:responsePromise,callback:responseCallback}=bu.exposedPromise();\n\t\t\t//Since we don't want responsePromise to be resolved, we don't use the method returned by \n\t\t\t//exposedPromise() and instead create one here... that we also use to log\n\t\t\tvar sent=false\n\t\t\tvar onSendSuccess=()=>{sent=true;}; \n\n\t\t\tresponsePromise=bu.promiseAlways(responsePromise,()=>{\n\t\t\t\t//Since @responseCallback wasn't passed in, we will only listen for the first response,so whatever\n\t\t\t\t//that response is (or if there is a problem with sending), unregister the request\n\t\t\t\tthis.cancelRequest(id);\n\t\t\t});\n\n\t\t\t//In case we've already sent, add a note so it's clear where the error comes from\n\t\t\tresponsePromise=responsePromise.catch(function requestFailed(err){\n\t\t\t\tif(sent)\n\t\t\t\t\treturn self.log.makeError(err)\n\t\t\t\t\t\t.addHandling(`This is an error-response to request ${id}`).reject();\n\t\t\t\telse\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t})\n\n\t\t\n\n\t\t\t//A timeout here (unlike with callback^) will fail an outstanding request\n\t\t\tif(timeout>0){\n\t\t\t\tlogStr+=`, timeout in ${timeout} ms`\n\t\t\t\tsetTimeout(()=>{\n\t\t\t\t\tif(this.sentRequests[id]){\n\t\t\t\t\t\tvar err=this.log.makeError(`Request (${id}) timed out after ${timeout} ms.`).setCode('timeout');\n\t\t\t\t\t\trequestFailed(err);\n\t\t\t\t\t}\n\t\t\t\t},timeout)\n\t\t\t}\n\t\t}\n\n\n\t\tthis.log.makeEntry('trace',logStr).addHandling(\"next step is preparing payload...\").exec();\n\t\tthis.sentRequests[id]=responseCallback;\n\t\treturn [id,sendPromise||responsePromise,onSendSuccess,onSendError||requestFailed];\n\t}\n\n\n\n\t/*\n\t* @no_throw\n\t* @return boolean \tTrue if a request was canceled, else false\n\t*/\n\tuniSoc_Client.prototype.cancelRequest=function cancelRequest(idOrCallback){\n\t\ttry{\n\t\t\tthis.log.traceFunc(arguments,'cancelRequest');\n\n\t\t\tif(bu.checkType(['number','function'],idOrCallback)=='number'){\n\t\t\t\tif(this.sentRequests[idOrCallback]){\n\t\t\t\t\tdelete this.sentRequests[idOrCallback];\n\t\t\t\t\treturn true;\n\t\t\t\t}else\n\t\t\t\t\tthis.log.warn(\"No pending request with id: \",idOrCallback);\n\t\t\t}else{\n\t\t\t\tvar id=this.sentRequests.indexOf(idOrCallback);\n\t\t\t\tif(id>-1){\n\t\t\t\t\tdelete this.sentRequests[id];\n\t\t\t\t\tif(this.sentRequests.indexOf(idOrCallback)>-1)\n\t\t\t\t\t\tthis.log.note(\"More than one instance of callback registered, only deleted first.\",idOrCallback)\n\t\t\t\t\treturn true;\n\t\t\t\t}else\n\t\t\t\t\tthis.log.warn(\"No pending request with callback: \",idOrCallback);\n\t\t\t}\n\t\t}catch(err){\n\t\t\tthis.log.error(\"Error trying to cancel request\",err);\n\t\t}\n\t\treturn false\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tfunction getFrom(payload){\n\t\tvar rinfo=Object.assign(bu.subObj(payload,'rinfo')||{},bu.subObj(payload,['ip','hostname','host','address','port'],true));\n\t\tvar address=rinfo.address||rinfo.host||rinfo.hostname||rinfo.ip||'', port=rinfo.port||''\n\t\tif(!address && !port)\n\t\t\treturn ''\n\t\telse\n\t\t\treturn ` from ${address}:${port}`\n\t}\n\n\n\n\t/*\n\t* Handler for responses received for a request (ie. used on original initiator's side to dispatch\n\t* the response to the caller)\n\t*/\n\tfunction receiveResponse(payload){\n\t\tif(typeof this.sentRequests[payload.id]!='function'){\n\t\t\tthrow new Error(`Received response to non-existent request ${payload.id}`);\n\t\t}\n\n\t\tvar msg=`response to ${payload.target}${getFrom(payload)}`\n\t\tif(payload.error==null){\n\n\t\t\tthis.log.debug(`${payload.id}: Received successfull ${msg}:`, payload.data);\n\n\t\t\t//If we've registered a middleware... ProTid: This is eg. where we may initiate a received smarty...\n\t\t\tif(typeof this.onresponse=='function'){\n\t\t\t\tthis.onresponse.call(this,payload);\n\t\t\t}\n\t\t\t\n\t\t}else{\n\t\t\t// console.log('FAILED RESPONSE:',payload.error);\n\t\t\tthis.log.note(`${payload.id}: Received failed ${msg}:`,this.log.makeError(payload.error).toString());\n\t\t}\n\n\n\n\t\t//Now call the response callback. \n\t\tvar shouldCancel=this.sentRequests[payload.id].call(null,payload.error,payload.data, payload);\n\n\t\t//If it returns 'cancel' then we cancel the request \n\t\tif(shouldCancel==='cancel'){\n\t\t\tthis.log.debug(\"responseCallback returned 'cancel', cancelling request....\")\n\t\t\tthis.cancelRequest(payload.id);\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\n\n\t/*\n\t* Callback used to respond to a request (ie. used on the non-initiator side to transmit the response)\n\t*\n\t* @param @bound object request \t\tThe received payload\n\t* @opt any error \t\t\t\t\tShould only be passed on error, else leave undefined. Errors may still\n\t*\t\t\t\t\t\t\t\t\t  still \n\t* @opt any data \t\t\t\t\tThe successfull data to return. If it's a promise and subsequently rejects\n\t*\t\t\t\t\t\t\t\t\t  it's future is determined by this.ondatareject\n\t*\n\t* @return Promise(boolean,n/a) \tAlways resolves after sending has been attempted with success boolean\n\t*\n\t* @bind(receiving socket, received payload)\n\t*/\n\tasync function responseCallback(request,error,data){\n\t\tvar success=true;\n\t\ttry{\n\t\t\tthis.log.traceFunc(arguments,`${request.id}: `);\n\t\t\t//Use the received object, but replace stuff with the new information we got. This way, \n\t\t\t//stuff like eg. 'address' and 'port' which dgram includes, gets passed back to send() \n\t\t\t//function and can be used if needed.\n\t\t\trequest.target=request.subject; //for use in logging\n\t\t\trequest.subject='__uniSoc_response';\n\n\t\t\t//If error or data were passed, set them, else let possible values already set on $request stand\n\t\t\trequest.error=(arguments.length>1 ? error : request.error)\n\t\t\trequest.data=(arguments.length>2 ? data : request.data)\n\n\t\t\tif(error=='__uniSoc_EALREADY'){\n\t\t\t\trequest.error={code:\"EALREADY\",msg:\"You already have an outstanding request with ID \"\n\t\t\t\t\t+request.id+\", please increment id or wait for response before requesting again\"};\n\t\t\t}else{\n\t\t\t\t//Even if sending fails vv, the request has been handled, so delete it\n\t\t\t\tdelete this.receivedRequests[request.id]\n\t\t\t}\n\n\t\t\tawait this.send(request);\n\t\t}catch(err){\n\t\t\tthis.log.error(`Failed to respond to request ${request.id}`,err);\n\t\t\tsuccess=false\n\t\t}\n\t\t//If we want to take any actions when we're no longer _working\n\t\ttry{\n\t\t\tif(!this.receivedRequests.length)\n\t\t\t\tthis.emit('_waiting');\n\t\t}catch(err){\n\t\t\tthis.log.error(\"BUGBUG:\",err)\n\t\t}\n\n\t\treturn success; //Always return resolved promise, since this is a best effort kind of thing\n\t}\n\n\n\n\t/*\n\t* This method gets called with ALL incomming messages and handles them in 1 of 3 ways:\n\t*   1) a new message => call endpoint/listener\n\t* \t2) a new request => create response callback => call endpoint/listener\n\t*\t3) the response to a request => receiveResponse() => calls the waiting callback\n\t*\n\t* @param object obj\n\n\t* @return void\n\t*/\n\tuniSoc_Client.prototype.receive=function(payload){\n\t\ttry{\n\t\t\tbu.checkProps(payload,{subject:'string'}); //sanity check that we passed the right thing\n\t\t\t// console.log('THIS IN receive:',this)\n\t\t\t// if(this.rinfo && payload.rinfo)\n\t\t\t// \tthis.log.highlight('red','rinfo in both socket and payload',this.rinfo,payload.rinfo)\n\t\t\t// else if(this.rinfo)\n\t\t\t// \tthis.log.highlight('blue','we have rinfo on socket',this.rinfo)\n\t\t\t// else if(payload.rinfo)\n\t\t\t// \tthis.log.highlight('blue','we have rinfo on payload',payload.rinfo)\n\t\t\t// else\n\t\t\t// \tthis.log.highlight('magenta','no rinfo ANYWHERE');\n\t\t\t\n\n\t\t\t//Check if this message is a response, or a new message wanting a response, or a new message\n\t\t\t//wanting nothing (like a multicast or the like...)\n\t\t\tpayload.id=Number(payload.id)||0\n\t\t\tvar id='';\n\t\t\tif(!payload.id){\n\t\t\t\tthis.log.debug(\"Received message (no response expected):\",payload);\n\n\t\t\t}else if(payload.subject=='__uniSoc_response'){\n\t\t\t\treceiveResponse.call(this,payload);\n\t\t\t\treturn;\n\n\t\t\t}else{\n\t\t\t\tid=payload.id+': ';\n\t\t\t\tthis.log.debug(`${id}Received request:`,payload); \n\n\t\t\t\t//Bind the response callback, and wrap it so it can only be called once!\n\t\t\t\tvar callback=bu.once(\n\t\t\t\t\tresponseCallback.bind(this,payload)\n\t\t\t\t\t,()=>this.log.makeEntry('warn','responseCallback() called multiple times! This time')\n\t\t\t\t\t\t.changeWhere(1).addFrom().exec()\n\t\t\t\t);\n\n\t\t\t\t//For simplicity require incoming messages to have unique id's so that logging and everything\n\t\t\t\t//matches everywhere. If duplicates arrive the sender will just have to send again. Technically \n\t\t\t\t//we don't need the id's for anything beyond logging, so we could skip this rule, but what the hell, \n\t\t\t\t//clashes should be so very far inbetween that we may as well not bother...\n\t\t\t\tif(this.receivedRequests.hasOwnProperty(payload.id)){\n\t\t\t\t\tcallback(\"__uniSoc_EALREADY\");\n\t\t\t\t\treturn;\n\n\t\t\t\t}else{\n\t\t\t\t\t//If we want to take any actions when we're no longer _waiting\n\t\t\t\t\tif(!this.receivedRequests.length){\n\t\t\t\t\t\tthis.emit('_working');\n\t\t\t\t\t}\n\n\t\t\t\t\t//In case we need to cancel the request early b/c eg. a shutdown... The callback is removed\n\t\t\t\t\t//from within itself once called...\n\t\t\t\t\tthis.receivedRequests[payload.id]=callback;\n\t\t\t\t}\n\t\t\t} \n\n\n\t\t\t//Now either call an endpoint or a listener\n\t\t\tvar ep=this.getEndpoint(payload.subject)\n\t\t\tif(ep){\n\t\t\t\t//Endpoints are 'special' listeners, limited to 1 per subject and registered with custom options via \n\t\t\t\t//registerEndpoint()\n\t\t\t\tep.listener.call(this,payload,callback); //callback will be undefined if not a request\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tvar l=this.countListeners(payload.subject,true)//true=>any listener, even onUnhandled() and onAll()\n\t\t\t\t\t,what=`for '${payload.subject}' ${callback?'with':'without'} callback`\n\t\t\t\t;\n\n\t\t\t\tif(l){\n\t\t\t\t\tthis.log.info((l>0? `${id}Calling ${l} listeners ${what}`:`${id}Calling ${-1*l} onAll/onUnhandled listeners ${what}`))\n\n\t\t\t\t\t//Regulare listeners get called with:\n\t\t\t\t\tthis.emitEvent(payload.subject,[payload.data,callback,payload.payload]);\n\t\t\t\t}else{\n\t\t\t\t\tthis.log.warn(`${id}New message on subject '${payload.subject}' received, but no handler registered. Payload:`, payload);\n\t\t\t\t\tif(callback){\n\t\t\t\t\t\tcallback('404 Not Found');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}catch(err){\n\t\t\t// console.error(err,payload);\n\t\t\tthis.log.makeError(err).addHandling('Error while handling incoming message:',payload).exec();\n\t\t}\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Transmitt all or some events from an emitter over the socket. \n\t*\n\t* NOTE: This is not suitable for streaming data (ie. reading from a file where thousands of \n\t*\t\tevents are emitted) since there is overhead with each transmitted event\n\t*\n\t* @param <BetterEvents>|object emitter \tMust have method .emit(), and that method must be called by name\n\t*\t\t\t\t\t\t\t\t\t\tfor the events to be extened. \n\t* @param object options \tThe following are available:\n\t*\t\t\t\t\t\t\t  exclude - function|array - Extend all but these events\n\t*\t\t\t\t\t\t\t  include - function|array - Ignored if 'exclude' passed. Extend only these events. \n\t*\t\t\t\t\t\t\t  prefix - string - Send all events individually with subject /prefix/evt\n\t*\t\t\t\t\t\t\t  subject - string - Ignored if 'prefix' passed. Send all events with this subject,\n\t*\t\t\t\t\t\t\t\t\t\t\t\t\tfirst arg will be evt\n\t*\n\t* @throw BLE(TypeError)\n\t* @return function|undefined \tIf $emitter is <BetterEvents> then the listener added to the emitter so\n\t*\t\t\t\t\t\t\t\tit can be used for removal or exclusion. For any other emitter, undefined.\n\t*/\n\tuniSoc_Client.prototype.extendEvents=function(emitter,options={}){\n\t\tbu.checkTypes(['object','object'],[emitter,options]);\n\n\t\tif(typeof emitter.on!='function' || typeof emitter.emit !='function'){\n\t\t\tthis.log.throwType(\"emitter object with .on() and .emit()\",emitter);\n\t\t}\n\t\t\n\t\tvar logStr=\"Extending\"\n\t\t\n\t\tvar {include,exclude,subject,prefix}=options;\n\n\t\t//First we need to know if we're filtering events\n\t\tvar filter;\n\t\tif(exclude){\n\t\t\texclude=[].concat(exclude)\n\t\t\tlogStr+=` all events except '${evts.join(\"','\")}'`\n\t\t\tfilter=(evt)=>exclude.indexOf(evt)==-1\n\t\t}else if(include){\n\t\t\tinclude=[].concat(include) //this deals with strings, arrays and undefined\n\t\t\tlogStr+=` events '${evts.join(\"','\")}'`\n\t\t\tfilter=(evt)=>include.indexOf(evt)>-1\n\t\t}else{\n\t\t\tlogStr+=` all events`\n\t\t\tfilter=()=>true;\n\t\t} \n\n\t\t//Then we need to know if we're interested in the results\n\t\tvar transmit;\n\t\tif(typeof emitter._betterEvents=='object'){\n\t\t\t//FUTURE NOTE: Since BetterEvents uses a loader we can't do instanceof because emitter may have loaded it itself\n\t\t\tlogStr+=' (responses ENABLED)'\n\t\t\ttransmit=this.request;\n\t\t}else{\n\t\t\tlogStr+=' (responses DISABLED)'\n\t\t\ttransmit=this.send;\n\t\t}\n\n\t//TODO 2019-12-21: Unregister the listener on _disconnect \n\t//TODO 2020-02-14: but then start listening again on reconnect\n\t\t//^ 2020-03-02: how would that work? when sockets are dead they're dead, any \"reconnect\" would be  a new socket\n\n\t\t//And finally if we're going to send all events under one subject, or prefix each event\n\t\tvar extendEventOverUniSoc;\n\t\tif(prefix){\n\t\t\tlogStr+=' using prefix '\n\t\t\textendEventOverUniSoc=((evt,...data)=>{\n\t\t\t\t// if(evt=='shutdown') console.log('------------------INTERCEPT SHUTDOWN')\n\t\t\t\tif(!this.connected) return;\n\t\t\t\tif(!filter(evt)) return;\n\t\t\t\treturn transmit.call(this,{subject:`${prefix}/${evt}`,data});\n\t\t\t}).bind(this);\n\t\t}else if(subject){\n\t\t\tlogStr+=' using single subject '\n\t\t\textendEventOverUniSoc=((...data)=>{\n\t\t\t\t// if(data[0]=='shutdown') console.log('------------------INTERCEPT SHUTDOWN')\n\t\t\t\tif(!this.connected){return;}\n\t\t\t\tif(!filter(data[0])){return;}\n\t\t\t\treturn transmit.call(this,{subject,data});\n\t\t\t}).bind(this);\n\t\t}else{\n\t\t\tlog.throw(\"Arg #2 must contain either 'prefix' or 'subject' option\")\n\t\t}\n\t\tlogStr+=`'${subject}'`;\n\t\tthis.log.debug(logStr,emitter);\n\t\t// console.log('----------------------------------------------------');\n\t\t// this.log.highlight('magenta',logStr,emitter);\n\n\n\t\t//Then we intercept all events on the emitter...\n\t\tif(typeof emitter._betterEvents=='object'){\n\t\t\t//FUTURE NOTE: Since BetterEvents uses a loader we can't do instanceof because emitter may have loaded it itself\n\t\t\t//...which is easier if the emitter is of our custom class\n\t\t\t//(use .onAll so events aren't treated as 'handled' just because they're exteneded)\n\t\t\temitter.onAll(extendEventOverUniSoc);\n\t\t\tthis.on('_disconnect',()=>emitter.removeListeners(extendEventOverUniSoc))\n\t\t\treturn extendEventOverUniSoc;\n\t\t}else{\n\t\t\tthis.log.note(\"Intercepting all calls to .emit() on:\",emitter)\n\t\t\t//...else we'll have to intercept by replacing the real emit function. \n\t\t\tvar original=emitter.emit;\n\t\t\t// FUTURE NOTE: Important we don't do emitter._emit=emitter.emit since extendEvents may be called\n\t\t\t//\t\t\t\tmultiple times => the second time emitter._emit==interceptEmit \n\t\t\tfunction newEmit(...args){\n\t\t\t\textendEventOverUniSoc.apply(null,args);\n\t\t\t\treturn original.apply(emitter,args);\n\t\t\t}\n\t\t\t//Make sure we don't change the enumerable properties of the object\n\t\t\tObject.defineProperty(emitter,'emit',{value:newEmit,writable:true,configurable:true\n\t\t\t\t,enumerable:emitter.propertyIsEnumerable('emit')})\n\n\t\t\tthis.on('_disconnect',()=>{\n\t\t\t\tif(emitter.emit==newEmit){\n\t\t\t\t\tdelete emitter.emit\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Common constructor for websockets from both npm's ws module and browsers Websocket API.\n\t*/\n\tfunction uniSoc_Websocket(options){\n\t\t//Call the uniSoc constructor as 'this', which sets a few things on this incl log\n\t\tuniSoc_Client.call(this,options);\n\t\t\n\t\tObject.defineProperty(this,'connected',{enumerable:true\n\t\t\t, get:()=>this.socket && this.socket.readyState==this.socket.OPEN})\n\n\t\t//Derived from:\n\t\t//  https://www.rfc-editor.org/rfc/rfc6455.txt  (ctrl+f for an error code)\n\t\t//  https://github.com/Luka967/websocket-close-codes\n\t\t// \thttps://docs.microsoft.com/en-us/dotnet/api/system.net.websockets.websocketclosestatus?view=netframework-4.8\n\t\tthis.log.codes={\n\t\t\t//These two are not errors, they just indicate normal behavior\n\t\t\t1000:\"Socket closed normally (this is the expected behavior).\"\n\t\t\t,1001:\"The socket is closing (eg. client is closing browser tab).\"\n\t\t\t\n\t\t\t//Reserved codes which MUST NOT be used manually\n\t\t\t,1005:\"Status code missing (ie. received a closing frame without status code).\"\n\t\t\t,1006:\"Connection closed unexpectedly (ie. no closing frame received at all)\"\n\n\t\t\t,1002:\"Protocol error (ie. received a frame that doesn't adhere to Websocket standard).\"\n\t\t\t,1007:\"Inconsistent data type (e.g. non-UTF-8 data within a text message).\"\n\t\t\t\n\t\t\t,1003:\"Policy violation: Unsupported data type (e.g. endpoint only understands text data, but received binary).\"\n\t\t\t,1009:\"Policy violation: Too much data (ie. message is too big to handle.).\" //relates to option 'maxPayload'\n\t\t\t,1008:\"Policy violation: Generic\"\n\n\t\t\t\n\t\t\t,1010:\"Server doesn't support extension demanded by client\"\n\t\t\t,1011:\"Internal server error\"\n\t\t\t,1012:\"Server is restarting\"\n\t\t\t,1013:\"Server is temporarily unable to fullfil client's request, try again later.\"\n\t\t\t,1014:\"Bad gateway (gateway received an invalid response)\"\n\t\t\t,1015:\"TLS handshake fail\"\n\t\t}\n\t}\n\tuniSoc_Websocket.prototype=Object.create(uniSoc_Client.prototype); \n\tObject.defineProperty(uniSoc_Websocket.prototype, 'constructor', {value: uniSoc_Websocket}); \n\n\n\n\n\t/*\n\t* Setup event listeners on websocket\n\t*\n\t* NOTE: This method should be called AFTER this.socket has been set, but does not need to \n\t*\t\twait for connect to have happened\n\t*\n\t* @return this\n\t*/\n\tuniSoc_Websocket.prototype.registerAllListeners=function(){\n\t\tif(!this.socket){\n\t\t\tthis.log.makeError(\"You cannot register listeners before having created/set this.socket\")\n\t\t\t\t.setCode('ESEQ').exec().throw();\n\t\t}else if(typeof this.socket.readyState!='number'){\n\t\t\tthis.log.throwType(\"this.socket to be instance of ws/Websocket\",this.socket);\n\t\t}else if(this.socket.onclose){\n\t\t\tthis.log.warn(\"Listeners already set on this.socket\").setCode('EALREADY').exec();\n\t\t}else{\n\t\t\tthis.log.debug(\"Regisering listners on websocket...\")\n\n\t\t\t//Start by clearing any previously emitted events since we'll be using .after() vv, \n\t\t\tthis.clearEmitted('_connect');\n\t\t\tthis.clearEmitted('_disconnect');\n\n\t\t\t//Make sure we emit a _connect event once (which will cause Server to add client to this.clients)\n\t\t\tif(this.connected){\n\t\t\t\tthis.log.debug(\"Websocket was already connected...\");\n\t\t\t\tthis.emitOnce('_connect'); //won't do anything if already emitted by listener ^\n\t\t\t}else{\n\t\t\t\tthis.socket.onopen=()=>{\n\t\t\t\t\tthis.log.debug(\"Websocket just connected now!\");\n\t\t\t\t\tif(!this.connected)\n\t\t\t\t\t\tthis.log.error(\"BUGBUG: We just connected, but this.connected is:\",this.connected);\n\t\t\t\t\tthis.emitOnce('_connect')\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tthis.socket.onclose=(event)=>{\n\t\t\t\tvar ble=this.log.makeCodeError(event.code,event.reason);\n\t\t\t\tif(event.wasClean){\n\t\t\t\t\tble.prepend('Websocket closed cleanly.').changeLvl('debug').exec();\n\t\t\t\t\tthis.on('_disconnect',()=>console.log('YUP, got _disconnect here...'));\n\t\t\t\t\tif(this.alreadyEmitted('_disconnect'))\n\t\t\t\t\t\tthis.log.warn(\"BUGBUG: _disconnect has already been emitted, but the socket JUST CLOSED...\");\n\t\t\t\t\tthis.emitOnce('_disconnect');\n\t\t\t\t}else{\n\t\t\t\t\tif(!this.alreadyEmitted('_connect')){\n\t\t\t\t\t\tble.prepend('Websocket failed to open.').setCode('CONN_FAIL',true); //true==only if no code exists\n\t\t\t\t\t}else{\n\t\t\t\t\t\tble.prepend('Websocket closed.').exec();\n\t\t\t\t\t}\n\t\t\t\t\tthis.emitOnce('_disconnect',ble);\n\t\t\t\t}\n\t\t\t};\n\n\n\t\t\tthis.socket.onerror=(event)=>{\n\t\t\t\tif(this.connected){\n\t\t\t\t\tthis.log.warn(\"Error occured, but connection still active:\",event);\n\t\t\t\t}\n\t\t\t\t// else{\n\t\t\t\t\t//no need to do anything, the onclose listner will fire\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\t//The message should already be a json string\n\t\t\tthis.socket.onmessage=(event)=>{\n\t\t\t\t// console.log('uniSoc4.common.ws.onmessage',event)\n\t\t\t\ttry{\n\t\t\t\t\tvar obj = JSON.parse(event.data);\n\t\t\t\t} catch(err){\n\t\t\t\t\tlet msg=err.message.replace('SyntaxError:','')\n\t\t\t\t\tthis.log.makeEntry('warn',\"Received badly formated JSON in message:\",msg,'\\n',event.data)\n\t\t\t\t\t\t.setCode('SyntaxError').exec();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.receive(obj);\n\t\t\t};\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\n\tuniSoc_Websocket.prototype._kill=function(){\n\t\t//If already closed, just resolve\n\t\tif(!this.socket || this.socket.readyState==this.socket.CLOSED)\n\t\t\treturn Promise.resolve();\n\n\t\t//If we're in the process of connecting, call this method again after a breif timeout\n\t\tif(this.socket.readyState==this.socket.CONNECTING)\n\t\t\treturn bu.sleep(100).then(()=>this._kill());\n\t\t\n\t\t//First start listening for the 'close' event\n\t\tvar {promise,resolve}=bu.exposedPromise(3000)\n\t\tthis.socket.addEventListener('close',resolve);\n\n\t\t//At this point the only possible states should be OPEN and CLOSING, and unless it's closing\n\t\t//we start to close now. Otherwise we just wait for the timeout vv\n\t\tif(this.socket.readyState!=this.socket.CLOSING)\n\t\t\tthis.socket.close();\n\n\t\t//...and if in 3 seconds we're not disconnected, force it\n\t\treturn promise.catch(err=>{\n\t\t\tif(err=='timeout'){\n\t\t\t\tif(this.socket && this.socket.readyState!=this.socket.CLOSED){\n\t\t\t\t\tlet msg='Socket still not closed after 3 sec';\n\t\t\t\t\tif(this.socket.terminate){\n\t\t\t\t\t\tthis.log.warn(msg+', forcing it...');\n\t\t\t\t\t\tthis.socket.terminate(); //only available on server-side, ie. part of npm ws module\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis.log.warn(msg+'...');\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis.log.note(\"BUGBUG: socket closed but 'close' event didn't fire...\");\n\t\t\t\t}\n\t\t\t\treturn; //This resolves the promise which causes .disconnect() to emit _disconnect... even\n\t\t\t\t\t\t//though we maaaaay still be connected\n\t\t\t}else{\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\n\n\t/*\n\t* Transmit an object over websocket (turning it into json string first);\n\t*\n\t* @param any obj\n\t*\n\t* @return Promise(true)\n\t*/\n\tuniSoc_Websocket.prototype._transmit=function(payload){\n\t\tlet str=JSON.stringify(payload);\n\t\tthis.log.trace(\"Transmitting...\",bu.logVar(str,50,'noLog'));\n\t\tthis.socket.send(str, (err)=>this.afterTransmit(err,payload)); \n\t}\n\n\n\n\n\n\tuniSoc.Client=uniSoc_Client;\n\tuniSoc.Websocket=uniSoc_Websocket;\n\n\treturn uniSoc;\n}\n\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./src/common.js?");

/***/ }),

/***/ "./src/web.js":
/*!********************!*\
  !*** ./src/web.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//simpleSourceMap=/my_modules/uniSoc/uniSoc4.web.js\n//simpleSourceMap2=/lib/uniSoc/uniSoc4.web.js\n;'use strict';\n/*\n* @module uniSoc\n* @author plundell\n* @license Apache-2.0\n* @description Frontend component of uniSoc. Wraps around native WebSocket API (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n*\n* @extends ./unisoc-common.js \t\n* @depends libbetter\n*\n* This script can be required by another script or bundled and loaded in the browser directly, making\n* it available at window.uniSoc\n*\n*/\n\n\nmodule.exports=function uniSoc_web_exporter(dep={}){\n\n\tconst uniSoc=__webpack_require__(/*! ./common.js */ \"./src/common.js\")(dep);\n\tconst bu = dep.BetterUtil  \t\t\t\t\t\n\n\n\tuniSoc_web.defaultOptions={\n\t\treconnectTimeout:5000\n\t};\n\n\t\n\n\tfunction uniSoc_web(options){\n\n\t\t//Call the common constructor as 'this', which sets a few things on this incl log\n\t\tuniSoc.Websocket.call(this,Object.assign({},uniSoc_web.defaultOptions,options));\n\n\t\tvar onconnect=()=>this.log.info('CONNECTED'); //define seperately so name in log is non <anonymous>\n\t\tthis.on('_connect',onconnect);\n\t}\n\tuniSoc_web.prototype=Object.create(uniSoc.Websocket.prototype); \n\tObject.defineProperty(uniSoc_web.prototype, 'constructor', {value: uniSoc_web}); \n\n\n\n\t/*\n\t* Unlike backend where sockets are generated by the server and passed into the equivilent constructor\n\t* function, here in browser we call connect() manually. That also means that we can reconnect (creating\n\t* a new Websocket on this.socket without having to create a whole new uniSoc_web)\n\t*\n\t* @opt object options \t\tAvailable options (will default to those passed to constructor):\n\t*\t\t\t\t\t\t\t\thost - string - if different from document hostname\n\t*\t\t\t\t\t\t\t\tpost - number - if different from document port\n\t*\t\t\t\t\t\t\t\tauth - string - if authentication is required\n\t* @flag 'reconnect'  \t\tIf set then this function always returns void (and logging\n\t*\t\t\t\t\t\t\tlooks a bit different)\n\t*\n\t* @return Promise(void,<BLE>)|void \tResolves when connected, rejects if and when connection fails\n\t*/\n\tuniSoc_web.prototype.connect=function(options,isReconnect){\n\t\ttry{\n\t\t\t//Throw if we're already connected (will be caught vv)\n\t\t\tif(this.connected)\n\t\t\t\tthis.log.makeError(\"Already connected\").throw('EALREADY');\n\n\t\t\t//Make sure the flag is intentional\n\t\t\tisReconnect=(isReconnect=='reconnect')\n\n\t\t\t//Save any options to this object\n\t\t\tif(options)\n\t\t\t\tObject.assign(this._options,options);\n\n\t\t\t//Build the url\n\t\t\tvar url='//'+(this._options.host ? this._options.host : document.location.host);\n\t\t\tif(this._options.port)\n\t\t\t\turl+=':'+this._options.port\n\n\t\t\turl=(document.location.protocol=='https:' ? 'wss:' : 'ws:')+url\n\t\t\tif(!isReconnect)\n\t\t\t\tthis.log.info(\"Attempting to connect to websocket:\",url).exec();\n\t\t\tthis.socket=new WebSocket(url,'json'); //2020-01-31: the 'json' doesn't seem to do anything...\n\t\t\tthis.registerAllListeners(); //will emit CONN_FAIL or _connect\n\t\t\t\n\t\t\t//Expose a promise and use it to catch those^ events\n\t\t\tvar {promise, resolve,reject,inspect}=bu.exposedPromise(5000);\n\t\t\tthis.once('_connect',resolve);\n\t\t\tthis.once('_disconnect',reject);\n\n\t\t\t//Finally return said promise\n\t\t\tvar stack=new Error().stack; //for debug purposes on fail vv\n\t\t\treturn promise.then(\n\t\t\t\t()=>{\n\t\t\t\t\t//remove listener since future disconnects aren't related to connection failure...\n\t\t\t\t\tthis.off('_disconnect',reject); \n\t\t\t\t\t//...and instead add a listener that will attempt to reconnect on future disconnects\n\t\t\t\t\tthis.once('_disconnect',()=>this.reconnect());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t,(err)=>{\n\t\t\t\t\tthis.off('_connect',resolve);\n\t\t\t\t\t\n\t\t\t\t\t//NOTE: Failed connections will be printed to the console regardless. So there is more data to\n\t\t\t\t\t// \t\tfind there that cannot be included in the log\n\n\t\t\t\t\tlet ble=this.log.makeError(err,this.socket).setStack(stack);\n\t\t\t\t\tthis.socket=null;\n\n\t\t\t\t\t//If this is a failed reconnect...\n\t\t\t\t\tif(isReconnect){\n\t\t\t\t\t\tble.prepend(`Reconnect failed.`);\n\t\t\t\t\t\t//The 1006 error (unexpected close) will be emitted if a server is unavailable, and it \n\t\t\t\t\t\t//will be printed to console regardless... so if that's the case just add an entry\n\t\t\t\t\t\t//to the log without printing anything\n\t\t\t\t\t\tif(ble.code==1006){\n\t\t\t\t\t\t\tble.changeLvl('debug').printed=true\n\t\t\t\t\t\t\tble.exec();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//Else it's something special and we print it full on\n\t\t\t\t\t\t\tble.exec();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Then just trigger another attempt.... but DON'T reject\n\t\t\t\t\t\tthis.reconnect();\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn ble.reject();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t\t\n\t\t}catch(err){\n\t\t\tlet ble=this.log.makeError(err).prepend('BUGBUG:');\n\t\t\tif(isReconnect)\n\t\t\t\tble.exec(); //On reconnect we just print it. NOTE: This will break the reconnect cycle\n\t\t\telse\n\t\t\t\treturn ble.reject();\n\t\t}\n\t\t\n\t}\n\n\t/*\n\t* Trigger a reconnect (and keep fireing at an interval, which is either passed in or\n\t* this._options.reconnectTimeout)\n\t*\n\t* @opt number interval \tThe new interval between attempts to use. If reconnect has previously\n\t*\t\t\t\t\t\t been disabled then a positive number is needed to trigger anything. The\n\t*\t\t\t\t\t\t value passed in will also be saved for future use\n\t* @return void\n\t*/\n\tuniSoc_web.prototype.reconnect=function(interval){\n\t\tif(interval && typeof interval=='number')\n\t\t\tthis._options.reconnectTimeout=interval;\n\n\t\tinterval=this._options.reconnectTimeout;\n\n\t\tif(interval){\n\t\t\tthis.log.trace(`Trying to reconnect in ${interval} ms.`)\n\t\t\tsetTimeout(()=>this.connect(null,'reconnect'),interval)\n\t\t}else{\n\t\t\tthis.log.note(\"Not reconnecting. See this._options.reconnectTimeout\");\n\t\t}\n\t}\n\n\t/*\n\t* Stop trying to reconnect.\n\t* @return void\n\t*/\n\tuniSoc_web.prototype.abortReconnect=function(){\n\t\tthis._options.reconnectTimeout=null;\n\t}\n\n\treturn uniSoc_web;\n}\n\n\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./src/web.js?");

/***/ })

/******/ });